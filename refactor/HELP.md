# 代码重构的技巧
最近在读《重构改善既有代码设计》,这里我会把所有案例放于此，以及一些笔记。如果有不正确、讲述不到位的请指正。

## 案例开篇

第一个案例是对一个电影票计费系统的重构，第一反应是策略模式，但是作者使用了状态模式，有什么区别呢？

### 策略模式 & 状态模式

#### 策略模式

一般涉及了复杂计算，且情况不同计算的方式也有所不同；不希望对外暴露算法具体实现细节；通过将算法进行抽象出来，然后算法类来实现这个抽象方法，需要调用者对算法有一定了解，进行手动选择计算策略。

#### 状态模式

一个事物的多种状态的表现，状态不同，行为就不同。

#### 区别

- 策略模式需要手动选择策略，状态模式的状态是系统运行过程中自己转换的；
- 策略模式始终都是一个事情的不同实现，本质上做的同一个事情；状态模式是多个状态的不同表现，做的事不同；

### 总结

- 无法方便地添加新特性，就先重构那个程序，使得特性比较容易进行之后添加。
- 重构之前，先准备好所有地测试用例，不然很容易出现bug 

## 如何重构

### 三次法则

#### 添加功能时重构

重构更好理解别人代码，同时能够发现代码的不足之处，能为之后的维护提供便利。

#### 修补时重构

如果出现bug，很大可能是代码不够清晰，可以考虑重构了。

#### 复审代码重构

复审代码时，如果有新的想法就立马看看能不能实现，可以更好地理解别人想法，同时发现更多不足之处，提供更多地修改建议。
- 大的团队建议设计评审
- 只是两个人直接代码评审，一起实现新方案。

### 重构、重写、重载

- 重载：发生在同一个类当中，同名方法，不同的入参个数、入参类型、入参顺序。
- 重写：发生在继承关系中，在返回类型、方法的实现、方法的权限三个方面进行修改
- 重构：只是修改方法的实现

### 总结
- 重构一定程度上解放了软件设计的工作量，良好的设计可以让后续性能优化提供更多时间。

## 何时重构

- 重复代码
- 过长函数
- 需要用到注释说明的时候
- 过大的类
- 过长的参数列表
- 发散式变化
- 散弹式修改
- 依恋情结
- 平行继承体系
- 冗余类
- 夸夸其谈未来性
- 令人迷惑的暂时字段
- 过度耦合的消息链
- 中国人
- 狎昵关系 
- 异曲同工的类
- 不完美的类库
- 纯稚的数据类

.....

### 总结 

把不变、与变化部分的剥离;高度耦合需要解耦（低耦合）;代码逻辑不明确的时候需要抽象出去方便理解;重复冗余的代码需要抽象再设计
;把相关的行为属性放在一起（高内聚）; 复合代替继承；

   
## chapter6

### 内联再重构

如果有多部份函数功能相关，且简单易懂，可以考虑重构这些函数到一个大函数内，然后重新抽取可能会有意想不到的结果！

如存在太多的间接层，但是都只是对另一个函数的简单委托，就应该考虑该重构。如果中间层复杂，且有继承关系，强烈建议放弃该重构。

### 用查询替换临时变量

原因：临时变量过多会大概率造成代码复杂，函数过长。如果临时变量只在函数中赋值一次才建议使用，且事先声明为final进行检查。

如果在一个魂环中，累加好几个数值的情况，把对每一个值的累加抽成一个函数。<u>不要担心性能影响，大概率不会影响且即使真的出现了性能问题也能很好内联回去！</u>

### 不要对入参进行赋值

原因：对按值传递、按引用传递的理解程度

例子：DataTester 调试一下，看看JVM中堆栈变化

### 函数对象取代函数

原因：如果某个函数存在了很多变量且关于这些变量的计算，可能是因为设计不佳，应该抽取到一个类--->高内聚

在实现了高内聚之后，在进行内部重构当然更加便捷！

### 总结

就是高内聚，实现内部尽可能的相关性

## chapter7

### 函数搬移

方法：
1. 检查要被搬移的函数中所使用的一切特性，考虑是否一起搬移。
2. 查看是否存在继承关系，是否搬移后会出错
3. 设计函数名符合新的目标类、以及原类如何调用该函数
4. 是否能调试通过

### 字段搬移

例子： 搬移Account利率到AccountType

```java
/**
 * @Description 修改前
**/
class Account{
    private AccountType type;
    private double interest;
    public double  getInterest() {
      return interest;
    }
}
/**
 * @Description 修改后
**/
class Account{
    private AccountType type;

    public double  getInterest() {
      return type.interest;
    }
}

class AccountType{
    private double interest;
    
    public double  getInterest() {
      return interest;
    }
}
```

<b>技巧：</b> 如果出现了很多地方对Account中interest的引用，就可以通过<b>委托</b>来实现。

### 类的抽泣

如果多个函数总是在同时间段出现，可以考虑抽离成新的对象。可以更好的并发编程，是不是锁粒度减小，但是如果要同时锁定两者的时候可能就要充分考虑事务问题了。

### 总结

就是低耦合，就是类之间尽可能少相关，类内部高的相关性。

