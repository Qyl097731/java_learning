# JVM学习

## 字节码

### 常见指令

https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5

### 常用工具

![image-20220816092516528](C:\Users\nsec\AppData\Roaming\Typora\typora-user-images\image-20220816092516528.png)

![image-20220816092600842](C:\Users\nsec\AppData\Roaming\Typora\typora-user-images\image-20220816092600842.png)



## 类加载及生命周期

### 加载阶段

##### 加载操作 

将字节码加载到内存，构建类模板对象。反射基于这一基础才得以实现。即加载二进制数据，生成class实例。

**-XX:+TraceClassLoading 追踪类加载轨迹**

##### 二进制获取方式

- 通过文件系统读入class后缀的文件
- 读入jar、zip等数据包，提取类文件
- 实现存放在数据库中的类的二进制数据
- 通过类似HTTP协议进行网络加载
- 运行时生成class的二进制信息

#####  类模型与class实例位置

- **类模型**

  1.8之前存放永久代；1.8之后存放元空间

- **class实例**

  存放在堆中，用来封装类的数据结构，在加载类的过程中创建

  构造方法是私有的，只有JVM能创建

##### 数组类的加载

不是类加载器负责创建，在运行时根据需要进行创建。数组元素通过类加载器创建。

### 链接阶段

##### 验证

- 保证加载的字节码是否合法

- 步骤
  1. 格式检查（加载阶段就开始了）
  2. 语义检查
  3. 字节码验证 （栈帧映射在此阶段，通过该监测也并非完全正确）
  4. 符号引用验证。（在解析环节执行）

##### 准备

- 为类的静态变量分配内存，初始化设置默认值，在初始化阶段赋值。
- **基本数据类型/String（不是new 出来）常量在编译时（载入字节码时）就分配初始化值，在准备阶段显式赋值**

**总结** 若static修饰 ：如果牵涉到需要new的都在clinit初始化赋值，如果确定不会new就直接准备阶段赋值，

##### 解析

- 将符号引用转化为直接引用

### 初始化阶段

- 执行类中定义的java程序代码，主要执行类的初始化操作<clinit>（线程安全）

  注意init是整个类初始化 clint是执行类中定义的方法

- 在加载类的时候，总是会试图加载父类，所以父类的clinit会咸鱼子类的clinit执行。即父类static先于子类static。

**主动使用 & 被动使用（不会被初始化）**

- 主动使用
  1. 当创建类实例，使用new、反射、克隆、反序列化
  2. 调用类的静态方法，即使用了invokestatic命令
  3. 使用类、接口的静态字段时
  4. 当初始化子类，发现父类还没初始化，要先触发父类初始化；接口除外，接口只有在调用其静态字段时，才会激活初始化；
  5. 但是一个接口定义了default，那么不管调用子类还是调用了接口中的静态字段，都会初始化。
  6. 虚拟机启动，用户指定一个执行类（含main方法），虚拟机会先初始化该类
  7. 初次调用MethodHadle实例时，初始化该MethodHadle指向的方法所在的类
- 被动使用
  1. 访问一个静态字段，只有真正声明这个字段的类才会被初始化，通过子类调用父类字段，不会导致子类初始化
  2. 通过数组定义类引用，不会引发类的初始化
  3. 引用常量不会触发类或者接口的初始化，因为在链接阶段就已经被显式赋值
  4. 调用ClassLoader类的loadClass()方法加载一个类，不是对类的主动使用，不会对类初始化

### 类的使用阶段

### 类的卸载阶段

##### 类、类的加载器、类的实例之间的引用关系

1. 类加载器内部，通过集合存放所加载类的引用，Class实例总是引用类加载器，通过Class.getClassLoader()获取类加载器
2. 一个类的实例可以通过Object的getClass方法获取该对象是哪个Class，同时所有类都有静态属性class表示对象所属的类Class。

##### 	类的生命周期

栈中存放引用地址，堆区存放对象，方法区（new 模板）存放类模板。

当类、类实例、类加载器都不再使用就回收。

### 	类加载器

#### 	作用

主要将类模板加载进来，交付给jvm进行连接初始化，是否可以运行由Execution Engine（执行引擎）决定

#### 	类加载的分类

**显示加载** ：通过ClassLoader加载，如Class.forName(name)或this.getClass().getClassLoader().loadClass()记载class对象

**隐式加载**：通过jvm自动加载

#### 	类的唯一性

1. 何为类的唯一性

   通过类加载器和类本身一同确认在JVM中的唯一性。比较两个类是否相等，只有在两个类在通过一个类加载器加载的前提下才有意义。

2. 命名空间

   - 由该加载器以及所有父加载器所加载的类组成

   - 同一命名空间中，不会由两个相同的类

   - 在不同的命名空间中，可能会出现类的完整名字相同的两个类

#### 	类加载机制的三个基本特征

1. 双亲委派模型

   **优点**：安全、避免重复加载、保护程序、防止核心api被篡改

   **缺点**：高层的类加载器无法识别被用户程序自定义实现了的基础类的接口

   **执行过程**：

   1. 查看缓存中是否有所需要的类
   2. 如果没有就查看是否有父类，若有通过父类进行加载
   3. 若没有通过调用启动类加载器进行加载
   4. 若都没有获取所需要的类，就通过自身进行类的加载

   双亲委派集中体现在2-3两步

   **破坏双亲委派**

   1. 重写loadClass就会破坏2-3两步，建议重写findClass方法
   2. 高层的类加载器无法识别被用户程序自定义实现了的基础类的接口。若类库本就需要用户进行继承、实现，但是显然高层的类加载器不会识别。故设计了线程上下文类加载器。
   3. 用户追求程序动态性：代码热替换（修改的代码能不停止服务，立即生效）、模块热部署

2. 可见性

   子类加载器可以访问父类的加载器，反过来不可以，会不能实现容器的逻辑

3. 单一性

   父类加载器对于子加载器可见，所以父加载器加载过的类型，子类不会再重复加载。同级的类加载器，同一类型可以多次加载，互不可见。

#### 	类加载器的分类

1. 引导类加载器

   - 启动类加载器 

     只加载java、javax、sun开头的类，为自定义类加载器指定父类加载器。

2. 自定义类加载器 派生于ClassLoader 的类加载器

   - 扩展类加载器
   - 应用程序类加载器（系统类加载器）
   - 自定义类加载器

   下层都含有上层加载器的引用

3. 附加说明

   - 引用类型数组元素类加载 就是数组的类加载器
   - 基本数据类型元素类预定义 不会加载
   - **线程上下文类加载器** 是系统类加载器，高层次类加载器通过委托线程上下文类加载器来调用低层次的类加载器。

4. Class.forName & ClassLoader.loadClass()

   - Class.forName加载Class的同时会进行类的初始化
   - ClassLoader.loadClass只是加载，不会初始化，直到类的第一次使用时才会初始化。

#### 自定义类加载器

##### 为什么要自定义类加载器

- 隔离加载器
- 修改类加载器方式
- 扩展加载器
- 防止源码泄露

## JVM调优

### 虚拟机参数

- -Xmx60m -Xms60m 设置堆大小

- -XX:SurvivorRatio=8 设置新生代中 Eden 和 Survivor占比 8：1：1

- -XX:+HeapDumpOnOutOfMemoryError 在程序OOM时，导出应用程序的当前堆快照

  -XX:HeapDumpPath: 指定堆快照保存位置

### 性能优化三部曲

1. 性能监控 

   非强制或者入侵方式收集、查看应用运营性能数据的活动，多数是预防或主动性活动

2. 性能分析 

   会影响应用的吞吐量或者响应，大多在系统测试或者开发环境进行

3. 性能调优

   更改代码、参数、属性配置，以较少内存获取较高吞吐以及响应时间

#### 性能指标

1. 响应时间

2. 吞吐量 

   -XX:GCTimeRatio = n

3. 并发数

4. 内存占用

5. 相互间关系

### 性能监控及调优工具

#### 虚拟机参数

- XX:+PrintFlagsInitial 显示jvm启动时的参数初始值
- XX:+PrintFlagsFinal 显示jvm参数的最终值
- XX:+PrintCommandLineFlags 查看被用户或者jvm设置过的详细的jvm参数
- -XX:+HeapDumpOnOutOfMemoryError 

##### 简单命令

- jps：查看正在运行的java进程

  - -q  只显示id 不显示主类的名称
  - -l   输出主类的全类名\jar包的完整路径
  - -m 输出虚拟机进程启动传递给主类main()的参数
  - -v  列出虚拟机启动时的JVM参数
  - hostid 查看服务器上的java进程 配合jstat使用

- jstat：查看JVM统计信息 主要用于监测垃圾回收和内存泄露问题

  ```bash
   jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]]
  ```

  **option**

  | 命令             | 作用                                                         |
  | :--------------- | ------------------------------------------------------------ |
  | class            | 显示ClassLoader的相关信息，类的装载、卸载数量、总空间、类装载所消耗的时间 |
  | gc               | 显示GC相关的堆信息，老年代、新生代、元空间                   |
  | gccapacity       | 与gc相似，但主要关注java堆各个区域使用到的最大最小空间       |
  | gcutil           | 与gc相似，输出主要关注已使用空间占总空间的百分比             |
  | gccause          | 与gcutil类似，额外输出导致最后一次发生GC产生的原因           |
  | gcnew            | 显示新生代状况                                               |
  | gcnewcapaciy     | ~                                                            |
  | gcodl            | ~                                                            |
  | compiler         | 显示jit编译器编译过的方法、耗时等资源                        |
  | printcompilation | 输出已经被jit编译的方法                                      |

  **-t** 

  打印上次监控输出到本次监控输出想间隔时间

  **-h**

  隔多少行打印一次表头

  **internel** 

  用于输出统计数据的周期，单位为毫秒

  **count**

  用于指定查询的次数

- jinfo：查看\调整虚拟机的配置参数

  以下参数参数同样可以直接实现

  - 

  直接通过jinfo命令查看可选参数

- jmap：导出内存镜像文件&内存使用情况,获取dump文件（对转存快照文件，二进制文件）

  - -head 输出整个堆空间的详细信息
  - -histo[:live] 输出堆中对象的统计信息，包括类、实力数量、合计容量,(:live只显示存活对象)
  - -dump[:live],format=b,file=filename.hprof pid 生成堆[存活对象]转储快照

  **小结：**为防止对象不被应用线程干扰，jmap借助安全点机制来暂停线程，可能导致对快照中的分析结果存在偏差。而jstat会让垃圾回收期自动记录，jstat只需要读即可。

- jhat：启动jhat就会启动http服务，可以在浏览器里分析jmap生成的堆快照文件。

- jstack：生成指定进程当前时刻的进程快照，追踪堆栈集合。

- jcmd：实现除了jstat之外的所有命令，可以导出堆、内存使用，查看java进程、导出线程信息、执行GC、JVM运行时间等

  - jcmd pid help显示所有可以执行的指令

  - 命令行形式进行监控：方法级别的分析数据无法获取