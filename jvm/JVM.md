- 当创建类实例，使用new、反射、克隆、反序列化
- 调用类的静态方法，即使用了invokestatic命令
- 使用类、接口的静态字段时
- 当初始化子类，发现父类还没初始化，要先触发父类初始化；接口除外，接口只有在调用其静态字段时，才会激活初始化；
- 但是一个接口定义了default，那么不管调用子类还是调用了接口中的静态字段，都会初始化。
- 虚拟机启动，用户指定一个执行类（含main方法），虚拟机会先初始化该类
- 初次调用MethodHadle实例时，初始化该MethodHadle指向的方法所在的类



- 访问一个静态字段，只有真正声明这个字段的类才会被初始化，通过子类调用父类字段，不会导致子类初始化

- 通过数组定义类引用，不会引发类的初始化
- 引用常量不会触发类或者接口的初始化，因为在链接阶段就已经被显式赋值
- 调用ClassLoader类的loadClass()方法加载一个类，不是对类的主动使用，不会对类初始化

-XX:+TraceClassLoading 追踪类加载轨迹





#### 类的卸载

##### 类、类的加载器、类的实例之间的引用关系

1. 类加载器内部，通过集合存放所加载类的引用，Class实例总是引用类加载器，通过Class.getClassLoader()获取类加载器
2. 一个类的实例可以通过Object的getClass方法获取该对象是哪个Class，同时所有类都有静态属性class表示对象所属的类Class。

##### 	类的生命周期

栈中存放引用地址，堆区存放对象，方法区（new 模板）存放类模板。

当类、类实例、类加载器都不再使用就回收。



### 	类加载器

#### 	作用

主要将类模板加载进来，交付给jvm进行连接初始化，是否可以运行由Execution Engine（执行引擎）决定

#### 	类加载的分类

**显示加载** ：通过ClassLoader加载，如Class.forName(name)或this.getClass().getClassLoader().loadClass()记载class对象

**隐式加载**：通过jvm自动加载

#### 	类的唯一性

1. 何为类的唯一性

   通过类加载器和类本身一同确认在JVM中的唯一性。比较两个类是否相等，只有在两个类在通过一个类加载器加载的前提下才有意义。

2. 命名空间

   - 由该加载器以及所有父加载器所加载的类组成

   - 同一命名空间中，不会由两个相同的类

   - 在不同的命名空间中，可能会出现类的完整名字相同的两个类

#### 	类加载机制的三个基本特征

1. 双亲委派模型

   ![image-20220816234127172](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20220816234127172.png)

   安全、避免重复加载、保护程序、防止核心api被篡改

2. 可见性

   子类加载器可以访问父类的加载器，反过来不可以，会不能实现容器的逻辑

3. 单一性

   父类加载器对于子加载器可见，所以父加载器加载过的类型，子类不会再重复加载。同级的类加载器，同一类型可以多次加载，互不可见。

#### 	类加载器的分类

1. 引导类加载器
   - 启动类加载器
2. 自定义类加载器 派生于ClassLoader 的类加载器
   - 扩展类加载器
   - 应用程序类加载器
   - 自定义类加载器

下层都含有上层加载器的引用

