# JVM学习

## 字节码

### 常见指令

https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5

### 常用工具

![image-20220816092516528](C:\Users\nsec\AppData\Roaming\Typora\typora-user-images\image-20220816092516528.png)

![image-20220816092600842](C:\Users\nsec\AppData\Roaming\Typora\typora-user-images\image-20220816092600842.png)



## 类加载及生命周期

### 加载阶段

##### 加载操作 

将字节码加载到内存，构建类模板对象。反射基于这一基础才得以实现。即加载二进制数据，生成class实例。

**-XX:+TraceClassLoading 追踪类加载轨迹**

##### 二进制获取方式

- 通过文件系统读入class后缀的文件
- 读入jar、zip等数据包，提取类文件
- 实现存放在数据库中的类的二进制数据
- 通过类似HTTP协议进行网络加载
- 运行时生成class的二进制信息

#####  类模型与class实例位置

- **类模型**

  1.8之前存放永久代；1.8之后存放元空间

- **class实例**

  存放在堆中，用来封装类的数据结构，在加载类的过程中创建

  构造方法是私有的，只有JVM能创建

##### 数组类的加载

不是类加载器负责创建，在运行时根据需要进行创建。数组元素通过类加载器创建。

### 链接阶段

##### 验证

- 保证加载的字节码是否合法

- 步骤
  1. 格式检查（加载阶段就开始了）
  2. 语义检查
  3. 字节码验证 （栈帧映射在此阶段，通过该监测也并非完全正确）
  4. 符号引用验证。（在解析环节执行）

##### 准备

- 为类的静态变量分配内存，初始化设置默认值，在初始化阶段赋值。
- **基本数据类型/String（不是new 出来）常量在编译时（载入字节码时）就分配初始化值，在准备阶段显式赋值**

**总结** 若static修饰 ：如果牵涉到需要new的都在clinit初始化赋值，如果确定不会new就直接准备阶段赋值，

##### 解析

- 将符号引用转化为直接引用

### 初始化阶段

- 执行类中定义的java程序代码，主要执行类的初始化操作<clinit>（线程安全）

  注意init是整个类初始化 clint是执行类中定义的方法

- 在加载类的时候，总是会试图加载父类，所以父类的clinit会咸鱼子类的clinit执行。即父类static先于子类static。

**主动使用 & 被动使用（不会被初始化）**

- 主动使用
  1. 当创建类实例，使用new、反射、克隆、反序列化
  2. 调用类的静态方法，即使用了invokestatic命令
  3. 使用类、接口的静态字段时
  4. 当初始化子类，发现父类还没初始化，要先触发父类初始化；接口除外，接口只有在调用其静态字段时，才会激活初始化；
  5. 但是一个接口定义了default，那么不管调用子类还是调用了接口中的静态字段，都会初始化。
  6. 虚拟机启动，用户指定一个执行类（含main方法），虚拟机会先初始化该类
  7. 初次调用MethodHadle实例时，初始化该MethodHadle指向的方法所在的类
- 被动使用
  1. 访问一个静态字段，只有真正声明这个字段的类才会被初始化，通过子类调用父类字段，不会导致子类初始化
  2. 通过数组定义类引用，不会引发类的初始化
  3. 引用常量不会触发类或者接口的初始化，因为在链接阶段就已经被显式赋值
  4. 调用ClassLoader类的loadClass()方法加载一个类，不是对类的主动使用，不会对类初始化

### 类的使用阶段

### 类的卸载阶段

##### 类、类的加载器、类的实例之间的引用关系

1. 类加载器内部，通过集合存放所加载类的引用，Class实例总是引用类加载器，通过Class.getClassLoader()获取类加载器
2. 一个类的实例可以通过Object的getClass方法获取该对象是哪个Class，同时所有类都有静态属性class表示对象所属的类Class。

##### 	类的生命周期

栈中存放引用地址，堆区存放对象，方法区（new 模板）存放类模板。

当类、类实例、类加载器都不再使用就回收。

### 	类加载器

#### 	作用

主要将类模板加载进来，交付给jvm进行连接初始化，是否可以运行由Execution Engine（执行引擎）决定

#### 	类加载的分类

**显示加载** ：通过ClassLoader加载，如Class.forName(name)或this.getClass().getClassLoader().loadClass()记载class对象

**隐式加载**：通过jvm自动加载

#### 	类的唯一性

1. 何为类的唯一性

   通过类加载器和类本身一同确认在JVM中的唯一性。比较两个类是否相等，只有在两个类在通过一个类加载器加载的前提下才有意义。

2. 命名空间

   - 由该加载器以及所有父加载器所加载的类组成

   - 同一命名空间中，不会由两个相同的类

   - 在不同的命名空间中，可能会出现类的完整名字相同的两个类

#### 	类加载机制的三个基本特征

1. 双亲委派模型

   ![image-20220816234127172](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20220816234127172.png)

   安全、避免重复加载、保护程序、防止核心api被篡改

2. 可见性

   子类加载器可以访问父类的加载器，反过来不可以，会不能实现容器的逻辑

3. 单一性

   父类加载器对于子加载器可见，所以父加载器加载过的类型，子类不会再重复加载。同级的类加载器，同一类型可以多次加载，互不可见。

#### 	类加载器的分类

1. 引导类加载器
   - 启动类加载器
2. 自定义类加载器 派生于ClassLoader 的类加载器
   - 扩展类加载器
   - 应用程序类加载器
   - 自定义类加载器

下层都含有上层加载器的引用