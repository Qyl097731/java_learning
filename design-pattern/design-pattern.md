设计模式学习


# 前言

Java学习过程中遇到的一些书中提及的设计模式汇总

# 设计模式

- 创建型（5个）：解决对象创建问题。
  - 单例模式 
  - 工厂方法模式 
  - 抽象工厂模式 
  - 建造者模式 
  - 原型模式
- 结构型（7个）：一些类或对象组合在一起的经典结构。
  - 代理模式
  - 装饰模式 
  - 适配器模式 
  - 组合模式 
  - 享元模式 
  - 外观模式 
  - 桥接模式
- 行为型（11个）：解决类或对象之间的交互问题。 
  - 策略模式 
  - 模板方法模式 
  - 责任链模式 
  - 观察者模式 
  - 迭代子模式
  - 命令模式 
  - 备忘录模式 
  - 状态模式 
  - 访问者模式 
  - 中介者模式 
  - 解释器模式

## 模板模式

## 代理模式

## 装饰模式

## 工厂模式

参见 factory 模块

### [简单工厂模式](src/main/java/com/nju/factory/simple/WeaponFactory.java)


简单工厂模式的优点：

- 客户端程序不需要关心对象的创建细节，需要哪个对象时，只需要向工厂索要即可，初步实现了责任的分离。客户端只负责“消费”，工厂负责“生产”。生产和消费分离。

简单工厂模式的缺点：
- 缺点1：工厂类集中了所有产品的创造逻辑，形成一个无所不知的全能类，有人把它叫做上帝类。显然工厂类非常关键，不能出问题，一旦出问题，整个系统瘫痪。
- 缺点2：不符合OCP开闭原则，在进行系统扩展时，需要修改工厂类。

Spring中的BeanFactory就使用了简单工厂模式。

### [工厂模式](src/main/java/com/nju/factory/real/AbstractWeaponFactory.java)

如果想扩展一个新的产品，只要新增一个产品类，再新增一个该产品对应的工厂即可，例如新增：匕首。不需要修改之前的源代码，显然工厂方法模式符合OCP原则。

工厂方法模式的优点：
- 一个调用者想创建一个对象，只要知道其名称就可以了。
- 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。
- 屏蔽产品的具体实现，调用者只关心产品的接口。
工厂方法模式的缺点：
- 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。


### [抽象工厂模式](src/main/java/com/nju/factory/abstractfactory/WeaponFactory.java)

原来的工厂模式不只能生产单一的商品，无法解决生产多个商品的问题，抽象工厂就是为了解决产品簇问题。

抽象工厂模式的优缺点：
- 优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。
- 缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在AbstractFactory里加代码，又要在具体的里面加代码。



## 单例模式

## 命令模式

## 映射器模式
